A principios de la década de 2000, gigantes tecnológicos como Google y Amazon comenzaron a superar sus bases de datos relacionales. Necesitaban procesar grandes volúmenes de datos de fuentes dispares que no encajaban perfectamente en el modelo de base de datos relacional. La aplicación de estructuras tabulares generaría problemas de redundancia de datos y rendimiento a escala, por lo que estas empresas lideraron el desarrollo de nuevas bases de datos no relacionales distribuidas para escalar sus plataformas web. De esta manera, las bases de datos NoSQL se desarrollaron para superar las limitaciones de las bases de datos relacionales, intercambiando ciertas características del RDBMS, como una sólida consistencia, uniones y un esquema fijo, para obtener más flexibilidad, escalabilidad y un rendimiento mejorado. Antes de continuar, aclaremos una cosa: NoSQL no significa No SQ, significa no solo SQL. Es una categoría de bases de datos que rompe con el marco relacional que vimos en el vídeo anterior. Sin embargo, algunas bases de datos no relacionales aún admiten SQL o SQL, como los lenguajes de consulta. Repasemos los conceptos básicos de las bases de datos NoSQL. Las bases de datos NoSQL tienen estructuras no tabulares. Pueden admitir varios formatos de datos, incluidos valores clave, documentos de columna ancha, gráficos y otros. Hablaré sobre la clave, el valor y la fuente del documento más adelante en este vídeo y verás algunos de estos otros tipos en los próximos cursos. A diferencia de las bases de datos relacionales, las bases de datos NoSQL no requieren esquemas predefinidos, lo que significa que tiene más flexibilidad a la hora de decidir cómo desea almacenar los datos. Las bases de datos NoSQL destacan por su escalado horizontal, lo que significa distribuir automáticamente los datos y las cargas de trabajo en varios servidores para satisfacer las crecientes demandas de tráfico. Cuando un usuario escribe datos en una base de datos NoSQL que está distribuida en varios servidores o nodos, la operación de escritura se realiza primero en un solo nodo de este sistema distribuido, que es una ubicación en la que se ejecuta una versión de la base de datos. En ese caso, es posible que se produzca un ligero retraso antes de que esos cambios se propaguen a todos los demás nodos del sistema. A diferencia de las bases de datos relacionales, las bases de datos NoSQL funcionan según el principio de una coherencia eventual en lugar de una sólida, lo que significa que la base de datos le permitirá leer desde un nodo que no haya recibido la última actualización de escritura y es posible que no obtenga los datos más actualizados. Sin embargo, con el tiempo suficiente, la base de datos será coherente y la lectura de los datos de cualquier nodo le proporcionará los mismos datos. Con una base de datos relacional que proporciona una coherencia sólida, no podrá leer los datos hasta que se hayan actualizado todos los nodos del sistema. De esta manera, la coherencia final no permite que ninguna base de datos individual priorice la velocidad. Esto es perfecto para aplicaciones en las que la disponibilidad y la escalabilidad del sistema son más importantes que la coherencia en tiempo real, como las plataformas de redes sociales o las redes de distribución de contenido. En cuanto a la integridad de los datos, no todas las bases de datos NoSQL garantizan los principios de atomicidad, coherencia, aislamiento y durabilidad, también conocidos como conformidad con ACID, que veremos en el siguiente vídeo, pero algunas sí, por ejemplo, MongoDB. Esto significa que si obtiene datos de una base de datos NoSQL, es posible que deba tomar medidas adicionales para garantizar la integridad de los datos. Por último, las bases de datos NoSQL utilizan lenguajes de consulta especializados adaptados a su modelo de datos, que a menudo, pero no siempre, son diferentes de los de SQL. Analicemos más de cerca dos tipos comunes de bases de datos NoSQL, las bases de datos de valores clave y las bases de datos de documentos. Una base de datos clave-valor almacena los datos como una colección de pares clave-valor, similar a lo que puede encontrar en un archivo JSON o en una estructura de diccionario de Python. La clave sirve como identificador único para recuperar el valor correspondiente. Tanto las claves como los valores pueden ser objetos simples o complejos. Este tipo de base de datos NoSQL es perfecto para escenarios en los que se necesita una búsqueda rápida de datos, como el almacenamiento en caché de los datos de las sesiones de usuario en una aplicación web o móvil. Por ejemplo, cuando un usuario inicia sesión en una aplicación de comercio electrónico, acciones como ver diferentes productos, añadir artículos al carrito de la compra y finalizar la compra se pueden almacenar en una base de datos de valores clave con el identificador de sesión del usuario como identificador único. Los almacenes de documentos son un tipo especial de base de datos de valores clave que almacenan datos en JSON como documentos. Cada documento tiene una clave única que identifica un documento y le permite recuperar los datos de ese documento. Los documentos se organizan en colecciones, por lo que puede pensar en una colección como una tabla en una base de datos relacional y en un documento como una fila. En este ejemplo, los datos se almacenan en una colección denominada usuarios. Cada documento representa a un único usuario y el identificador es la clave que identifica de forma exclusiva a cada usuario. Esta localidad facilita la recuperación de toda la información sobre un usuario en particular en comparación con una base de datos relacional, donde la información del usuario puede estar distribuida en varias tablas. Sin embargo, los almacenes de documentos no admiten combinaciones, por lo que es más difícil y menos eficiente combinar información de varios documentos en comparación con combinar información de varias tablas en una base de datos relacional. La ventaja, sin embargo, es la noción de un esquema flexible. Como ha visto con las bases de datos relacionales, todos los registros deben ajustarse a un esquema fijo, pero con las bases de datos de valores clave y los almacenes de documentos, los registros de datos no tienen una estructura fija o predefinida. Los almacenes de documentos se utilizan habitualmente para aplicaciones que incluyen catálogos de administración de contenido y lecturas de sensores. Cada interacción, producto o lectura de sensor de un dispositivo de IoT, por ejemplo, se puede almacenar como un único documento con un esquema flexible. Pero ten cuidado, esta flexibilidad puede tener un inconveniente. He visto cómo las bases de datos de documentos se convierten en pesadillas absolutas para gestionar las consultas. Y si está ingiriendo datos de un almacén de documentos NoSQL como sistema de origen, la flexibilidad del esquema hace que sea aún más fácil para los propietarios del sistema de origen cambiar algo que interrumpa sus canalizaciones de datos. Tanto las bases de datos relacionales como las bases de datos NoSQL se pueden utilizar como una especie de amplia gama de aplicaciones. Cuando se trata de aplicaciones que procesan transacciones en línea en áreas como la banca, las finanzas y el comercio electrónico, entre otras, las cosas suceden rápidamente, el dinero cambia de manos y los productos están en movimiento. Y en este tipo de aplicaciones de procesamiento de transacciones en línea o OLTP, cualquier error o inconsistencia en los datos puede causar problemas importantes. En el siguiente vídeo, analizaremos los principios de atomicidad, coherencia, aislamiento y durabilidad, también conocidos como principios ACID, que son de vital importancia para sus fuentes de datos y canalizaciones de datos cuando trabaje con sistemas OLTP. Nos vemos allí.

Tanto las bases de datos relacionales como las no relacionales pueden soportar tasas de transacción muy altas. Se usan comúnmente en el procesamiento de transacciones en línea o en los sistemas OLTP. Por lo general, estos sistemas necesitan almacenar los estados de las aplicaciones que cambian rápidamente, como los detalles de los saldos de las cuentas bancarias o los pedidos en línea. La mayoría de los sistemas de bases de datos relacionales cumplen con lo que se conoce como compatibles con ACID, lo que significa que cumplen con los principios de atomicidad, coherencia, aislamiento y durabilidad, lo que ayuda a garantizar que las transacciones se procesen de manera confiable y precisa en un sistema OLTP. Por el contrario. Muchas bases de datos NoSQL no cumplen con los activos de forma predeterminada, pero muchas le ofrecen la posibilidad de configurarlas para que cumplan con los activos. En este vídeo, voy a hablar sobre qué es cada principio de activo para que pueda tener una mejor idea de cuándo se aplicarán estos principios al trabajo que realiza como ingeniero de datos. Pero primero, pensemos por un momento en lo que ocurre si las transacciones, por ejemplo, se realizan en un sistema bancario o no se procesan de manera confiable o precisa. Por ejemplo, ¿qué pasa si intentas transferir dinero en línea de una cuenta a otra y el sitio web del banco simplemente deja de funcionar mientras intentas transferir dinero? Cuando finalmente regreses a tu cuenta, esperarás descubrir que la transacción se realizó o no, pero no que el dinero se haya deducido de una cuenta, pero no que el dinero se haya deducido de una cuenta, pero no se haya agregado a la otra. Lo mismo se aplica a todos los sistemas, desde la banca hasta las compras en línea y muchos más. El primer principio de los activos es la atomicidad, que garantiza que las transacciones sean atómicas o, en otras palabras, que se traten como una sola unidad indivisible. Una transacción puede constar de varias operaciones. Sin embargo, el principio de atomicidad garantiza que todas las operaciones de una transacción se ejecuten correctamente o que ninguna de ellas lo haga. Por ejemplo, imagine la transacción de un cliente que hace un pedido de un artículo. Supongamos que esta transacción implica dos operaciones: deducir el costo total de la cuenta del cliente y actualizar el inventario para reflejar el artículo comprado. Supongamos que el cliente experimenta un error de conexión de red justo después de deducir el coste total de su cuenta. Pero antes de que se completara la actualización del inventario. El principio de atomicidad garantiza que ambas operaciones se realicen como una sola transacción. Si el error de conexión de red impide que se complete la segunda operación, la primera se anulará, por lo que no se cobrará al cliente y se producirá un error en toda la transacción. El segundo principio es la coherencia, lo que significa que cualquier cambio en los datos realizado dentro de una transacción debe seguir el conjunto de reglas o restricciones definidas por el esquema de la base de datos. Esto garantiza que la base de datos pasará de un estado válido a otro. Por ejemplo, supongamos que el esquema de la base de datos de inventario evita que cualquier nivel de existencias descienda por debajo de cero. Supongamos que el nivel de existencias de un artículo en particular es actualmente uno. Si un cliente intenta hacer un pedido de dos de esos artículos, la operación fallará y se descartará toda la transacción para garantizar que la base de datos siga siendo coherente con el esquema predefinido. Como ya he mencionado, este es el valor predeterminado en las bases de datos relacionales, pero tendría que configurarse en la mayoría de los sistemas NoSQL. Solo una nota para mayor claridad, la palabra coherencia termina sobrecargándose un poco aquí. En el vídeo anterior, describí la sólida propiedad de consistencia de las bases de datos relacionales, que hace referencia a la idea de que todos los nodos de un sistema distribuido proporcionarán los mismos datos actualizados. Resulta que la consistencia sólida de un sistema de base de datos es el resultado del cumplimiento de los principios de ACID, pero es un concepto ligeramente diferente al de la consistencia representada por la C en ACID. El siguiente principio es el aislamiento, que garantiza que cuando varios clientes intentan ejecutar transacciones simultáneamente, cada transacción se ejecute de forma independiente en orden secuencial. Por ejemplo, supongamos que el inventario muestra que quedan 10 unidades de un artículo. Supongamos que dos clientes hacen cada uno un pedido de cinco de estos artículos al mismo tiempo. El principio de aislamiento garantiza que, aunque la marca de tiempo de estas dos transacciones sea la misma, ambas transacciones se realizarán de forma independiente en secuencia, de modo que cuando se completen las dos transacciones, el nivel de inventario de ese artículo será cero y no cinco. Del mismo modo, si un cliente pide cinco y otro pide 10 del artículo al mismo tiempo, el pedido que se procese primero, lo procesaremos y el segundo fallará, lo que dará como resultado un nivel de inventario de cinco o cero. El principio final es la durabilidad, que garantiza que, una vez que se complete una transacción, sus efectos sean permanentes y sobrevivan a cualquier fallo posterior del sistema, como una pérdida de energía. Esto es esencial para mantener la confiabilidad de la base de datos, incluso cuando se enfrenta a un evento inesperado, como un desastre natural. En resumen, los principios ACID garantizan que una base de datos mantendrá una imagen coherente del mundo. Eso puede parecer lógico y relativamente sencillo. Sin embargo, en el mundo real, una base de datos puede particionarse en varios servidores debido a su tamaño o replicarse en varios centros de datos para lograr redundancia y velocidad. En estos casos, es especialmente importante saber que los datos que está leyendo y escribiendo permanecen consistentes en toda la red de servidores. Este es el principio de lo que se denomina consistencia sólida, que es una característica clave del cumplimiento de ACID que se mantiene incluso en un sistema de base de datos distribuido. Ahora bien, es importante tener en cuenta que, si bien las bases de datos relacionales suelen cumplir con ACID, no todas las bases de datos deben cumplir con todos los principios de ACID para poder soportar los backends de las aplicaciones. Algunas bases de datos NoSQL solo poseen cierto grado de conformidad con ACID. Sin embargo, al relajar una o más de estas restricciones, puede mejorar ciertos aspectos del rendimiento de las bases de datos y hacerlas más escalables. Como ingeniero de datos, comprender cuándo su base de datos debe cumplir con ACID puede ayudarlo a prevenir desastres. En el siguiente laboratorio, trabajará con DynamoDB, una base de datos de valores clave de NoSQL. Acompáñeme en el siguiente vídeo para echar un vistazo rápido al laboratorio antes de entrar.

En el siguiente laboratorio, trabajará con Amazon DynamoDB como base de datos de valores clave y aplicará algunas operaciones de creación, lectura, actualización y eliminación o CRUD a los datos de esta base de datos NoSQL. En este vídeo, le proporcionaré una descripción general de algunas de las funciones de DynamoDB, los datos con los que trabajará y algunos de los métodos de DynamoDB que utilizará para aplicar operaciones CRUD a los datos. DynamoDB es una base de datos de valores clave que almacena un conjunto de elementos de valores clave en una tabla. Cada fila contiene los atributos de un elemento y se identifica de forma exclusiva mediante la clave del elemento. Por ejemplo, aquí hay dos elementos de valor clave en los que cada uno corresponde a una persona. La clave representa el identificador de la persona y el valor consiste en un conjunto de atributos que describen a la persona. DynamoDB almacena estos datos en una tabla, como se muestra aquí. Cada fila contiene el identificador de la persona y los atributos correspondientes. Dado que una columna de ID de persona identifica de forma exclusiva cada fila, representa la clave principal de esta tabla. Cuando trabaja con DynamoDB, también puede hacer referencia a la clave principal como clave de partición. Esto se debe a que DynamoDB usa la clave principal para determinar la partición o, dicho de otro modo, el almacenamiento físico en el que se almacenará el elemento. También puede definir una clave principal compuesta para una tabla de DynamoDB. Por ejemplo, esta es una tabla en la que cada fila representa el artículo de un pedido y se identifica de forma única mediante una clave principal compuesta. Esta clave compuesta se compone de dos claves. La primera representa el identificador del pedido y se denomina clave de partición. La segunda representa el número de línea del artículo con un pedido y se denomina clave de clasificación. Con esta clave compuesta, puede tener dos elementos con la misma clave de partición, pero deben tener diferentes claves de clasificación, de modo que pueda identificar cada elemento de forma única. DynamoDB usa la clave de partición para determinar en qué partición se almacenará el elemento y la clave de clasificación para ordenar los elementos de la misma partición. En estas dos tablas, puedes ver que cada elemento puede tener sus propios atributos distintos. Esto se debe a que las tablas de DynamoDB no tienen esquemas, lo que significa que no es necesario definir los atributos de antemano. En este laboratorio, creará cuatro tablas de DynamoDB e interactuará con ellas mediante código Python en un cuaderno Jupyter. Para ello, utilizará Boto3, que es el kit de desarrollo de software de AWS que le permite crear y configurar los servicios de AWS mediante Python. Esta es la documentación de Boto3, donde encontrará una lista de métodos que puede utilizar para interactuar con varios recursos de AWS. Si hace clic en DynamoDB aquí, encontrará la lista de todos los métodos disponibles que puede usar al trabajar con una tabla de DynamoDB. En el laboratorio, se centrará en los métodos que puede usar para aplicar las operaciones CRUD, como CreateTable para crear las tablas, putItem, WriteBatchItems, updateItem para agregar o actualizar elementos en las tablas creadas, scan, getItem, query para leer los elementos de las tablas y DeleteItem para eliminar elementos de las tablas. Para llamar a estos métodos, primero debe crear un objeto de cliente, como se muestra aquí, que le proporciona una interfaz que representa una tabla de Amazon DynamoDB. Con este objeto de cliente, llamará a cualquiera de estos métodos de DynamoDB. Para crear las tablas, se proporcionan estos cuatro archivos JSON que se descargan de la Guía para desarrolladores de Amazon DynamoDB. Leerá y cargará cada uno de los contenidos en una tabla de DynamoDB. El archivo del catálogo de productos contiene información sobre algunos productos que se venden en Amazon. Cada producto se define por su identificador, que utilizarás como clave principal simple para la tabla correspondiente. El archivo del foro contiene información sobre algunos foros de AWS en los que los usuarios publican preguntas o inician hilos sobre los servicios de AWS. Para cada foro, puedes encontrar el número total de hilos, mensajes y vistas. Cada foro se define por su nombre, que utilizarás como clave principal simple para la tabla correspondiente. El archivo de hilo contiene información sobre cada hilo del foro, como el asunto del hilo, el mensaje del hilo, el número total de visitas y respuestas al hilo determinado. Cada hilo se define por el nombre del foro y el asunto del hilo, que utilizarás como clave principal compuesta para la tabla correspondiente. El archivo de respuesta contiene información sobre las respuestas de cada hilo, como la hora de la respuesta, el mensaje de respuesta, el usuario que publicó la respuesta y el ID de la respuesta, que es una concatenación del foro y el asunto del hilo. Cada respuesta se define por el identificador y la hora de la respuesta, que utilizarás como clave principal compuesta para la tabla correspondiente. Echemos un vistazo al archivo del foro. Contiene una lista de elementos de solicitud de venta, cada uno de los cuales contiene un único elemento. Extraerá los atributos de cada elemento y, a continuación, los cargará en la tabla de DynamoDB. Tenga en cuenta que cada atributo está definido por otro par clave-valor para definir el tipo del atributo y su valor. Por lo tanto, la letra N, que significa número, y la S, que significa cadena, son ejemplos de descriptores de tipos de datos de DynamoDB que indican a DynamoDB cómo interpretar el tipo de cada atributo. Todos los archivos JSON restantes siguen el mismo patrón, por lo que te animo a que hojees rápidamente los demás archivos JSON para comprender mejor cada uno de ellos. Repasemos ahora el primer ejercicio del laboratorio. Ya empecé el laboratorio y abrí este cuaderno de Jupyter. Ejecutaré esta celda para importar los paquetes necesarios y luego esta celda para definir esta variable que usará en el laboratorio con fines de etiquetado. Tras estas dos celdas, encontrará una explicación sobre los datos y la tabla de DynamoDB, que ya he explicado en este vídeo. El primer ejercicio consiste en crear las cuatro tablas en las que utilizará el método CreateTable de Boto3. Si consulta la documentación, verá que este método espera un nombre para la tabla y una definición para la clave principal. Puede definir los atributos que componen la clave principal mediante el argumento de definiciones de atributos. Con el argumento del esquema de claves, puede especificar para cada atributo si es una clave de partición o una clave de clasificación. Hash aquí significa clave de partición y rango significa clave de clasificación. En el laboratorio, no necesitará codificar estos argumentos para cada tabla. En su lugar, se le proporcionan estos diccionarios que representan los argumentos de cada tabla. Para crear las tablas, se le proporciona esta función CreateTableDB dentro de la cual llamará al método CreateTable de Boto3. La función CreateTableDB toma el nombre de la tabla y quargs, que es la abreviatura de argumentos de palabras clave, es un diccionario que contiene los argumentos adicionales del método Boto3. Las dos estrellas situadas junto a los cuarteles significan que los elementos del diccionario están desempaquetados en una secuencia de argumentos. Aquí tendrás que completar esta línea de código en la que se llama al método Boto3 mediante el objeto cliente. Para el nombre de la tabla, usaré la entrada TableName y luego pasaré los argumentos restantes usando quargs. Ahora ejecutaré la celda y las dos celdas siguientes para crear las tablas. Y desde aquí, puedes seguir trabajando en los ejercicios restantes. Ten en cuenta que algunos de los ejercicios están marcados como opcionales, así que no dudes en saltarte las partes opcionales. Después del laboratorio, acompáñeme en el siguiente vídeo para ver el segundo tipo principal de sistema de almacenamiento con el que trabajará, los archivos y, más específicamente, los archivos en el almacenamiento de objetos en la nube.
